# 什么是面向对象

## 面向过程

面像过程就是八个字：自顶向下，逐步细化！

把问题分解成一个一个步骤，每个步骤用函数实现，使用时依次调用函数即可。比如实现一个简单的冒泡算法。

**优点**：性能比面向对象好，因为类调用时需要实例化，开销比较大比较耗资源。

**缺点**：不易维护，不易复用，不易扩展。

## 面向对象

### 面向对象概念

将事务高度抽象化的编程模式，将问题分解成一个个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是在面向对象编程的时候要把属性和行为等封装成对象，然后基于这些对象及这些对象的能力进行业务能力的实现。

**优点**：易维护，易复用，易扩展。由于面向对象有封装，继承，多态特性，可以设计出低耦合的系统，使系统更加灵活，更易维护。

**缺点**：性能比面向过程差。

### 三大基本特征

- 封装

  将类的某些特征隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法实现对象隐藏信息的操作和访问。原则：将不需要对外提供的内容都隐藏起来；把属性隐藏，通过公共方法访问。

- 继承

  多个类拥有相同的属性和行为时，将这些内容单独抽取到一个类中，其它类通过继承便可以拥有这些属性和行为。继承的类叫：子类或派生类。被继承的类叫：父类或超类

- 多态

  同一事物在不同时刻表现的状态，多态的前提是继承。

### 五大基本原则

- 单一职责原则(SRP)

  一个类的功能要单一，只做一件事。

- 开放封闭原则(OCP)

  软件对于扩展是开放的，对于修改是封闭的。对扩展开放意味着有新的需求和变化时，可以对现有代码进行扩展适应新的情况。修改是封闭的，即类一旦设计完成便可以独立完成工作而不要对其尝试修改。

- 里氏替换原则(LSP)

  子类可以替换父类出现在父类能够出现的任何地方.

- 依赖倒置原则(DIP)

  高层次模块不依赖底层模块，二者都同时依赖于抽象。抽象不依赖于具体，具体依赖于抽象。

- 接口隔离原则(ISP)

  使用多个小的专门的接口，而不要使用一个大的总接口。一个类对另外一个类的依赖应该建立在最小接口上，不要强迫依赖不用的方法，这是一种接口污染。

# 平台无关性

## 什么是平台无关性

平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译到处执行。

## 平台无关性的好处

作为平台无关性的语言，无论是在自身发展还是对开发者的友好度上都是很突出的。因为平台无关性，所以Java程序可以运行在各种各样的设备上，尤其是一些嵌入式设备，如打印机，扫描仪等。

## 平台无关性的实现

对于Java的平台无关性的支持是分布在整个Java体系结构中的。其中扮演重要角色的有Java语言规范、Class文件、Java虚拟机等。

### Java语言规范

通过规定Java语言中基本数据类型的取值范围和行为

有了Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java也并不能实现跨平台。Java语言在跨平台做了一些规范。

Java中基本数据类型的值域和行为都是由其自己定义的。而c/c++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以在不同的平台中，对于同一个c++程序的编译结果会出现不同的行为。

![](../../pic/data_type_length.png)

### Class文件

所有Java文件要编译成统一的Class文件

各种不同的平台虚拟机都是用统一的程序存储格式-字节码(ByteCode)是构成平台无关性的另一个基石。Java虚拟机只与字节码组成的Class文件进行交互。

Java语言的Write Once，Run Anywhere，这里的write其实指的就是生成Class文件的过程。因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有Java的平台无关性。

### Java虚拟机

通过Java虚拟机将Class文件转成对应平台的二进制文件

所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是对于不同的平台，硬件和操作系统肯定是不一样的。对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。想要做到跨平台，最终的就是可以根据对应的硬件和操作系统生成对应的二进制指令。

而这一工作主要就是由Java虚拟机完成，虽然Java语言是平台无关的，但是JVM确实平台有关的，不同的操作系统上面要安装对应的JVM。

# 值传递

## 错误理解

1.值传递和引用传递，区分的条件是传递的内容，如果是个值，就是值传递。如果是个引用，就是引用传递。

2.Java是引用传递。

3.传递的参数如果是普通类型，那就是值传递，如果是对象，那就是引用传递。

## 实参和形参

参数在程序语言中分为形参。实际参数是调用有参方法的时候真正传递的内容，而形式参数是用于接收实参内容的参数。

- 形式参数：是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传入的参数。
- 实际参数：在调用有参函数时，主调函数和被调函数之间有数据传递关系。在主调函数中调用一个函数时，函数名后面括号中的参数称为实际参数。

## 值传递与引用传递

当调用一个有参函数的时候，会把实际参数传递给形式参数。在程序语言中，这个传递过程中传递的两种，即值传递和引用传递。

- 值传递(pass by value)是指在调用时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响懂啊实际参数
- 引用传递(pass by reference)是指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。

值传递和引用传递的区别并不是传递的内容。而是实参到底有没有被复制一份给形参。在判断实参内容有没有受影响的时候，要看传的是什么，如果你传递的是个地址，那么就看这个地址的变化会不会有影响，而不是看地址指向的对象的变化。

所以Java是值传递，只不过对于对象参数，值的内容是对象的引用。

无论是值传递还是引用传递，其实都是一种求值策略(Evaluation strategy)。在求值策略中，还有一种做按共享传递。其实Java中的参数传递严格意义上说应该是按共享传递

>按共享传递，是指在调用函数时，传递给函数的是实参的地址的拷贝(如果实参在栈中，则直接拷贝该值)。在函数内部对参数进行操作时，需要先拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝的值，所以函数内部对参数进行操作不会对外部变量产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到对中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的

# 类

## 对象

类是一组相关的属性和行为集合，对象是该类事物的具体体现

## 匿名对象

就是没有名字的对象，是对象的一种简化表现形式。匿名对象两种使用情况：对象调用方法仅仅一次时候，作为实参。

- 优点：匿名对象调用完毕就是垃圾，可以被垃圾回收器回收。匿名对象可以作为实际参数传递
- 缺点：匿名对象不能多次调用方法。只能重复new对象，浪费内存

## 变量

- 类变量

和成员变量一样，只不过用static修饰符修饰。

- 成员变量

在类方法外，存在于堆中，随着对象的存在而存在，随着对象的消失而消失，有默认的初始化值。

- 局部变量

在方法内或者方法声明上，存在于栈中，随着方法的调用而存在，随着方法的调用完毕而消失，没有默认的初始化值，必须先定义并且赋值，才能使用。

## 方法

- 定义

方法就是完成特定功能的代码块：在很多语言里面都有函数的定义：函数在java中被称为方法

- 格式

> 修饰符   返回值.  方法名（参数类型参数名1， 参数类型 参数名2......）{
>
> ​			函数体;
>
> Return 返回值;
>
> }

- 特征

1.方法不调用不执行

2.方法与方法是平级关系，不能嵌套定义

3.方法定义的时候，参数之间用逗号隔开

4.方法调用的时候不用再传递数据类型

5.如果方法有明确返回值，一定要有return带返回值

- 重载

在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

## 构造函数

- 作用

  给对象的数据进行初始化

- 格式

  方法名与类名相同

  没有返回值类型，连void都没有

  没有具体的返回值

- 注意事项

  如果你不提供构造方法，系统会给出默认构造方法

  如果你提供了构造方法，系统将不再提供

  构造方法也是可以重载的

## this&super

- this

this:代表所在类的对象引用，方法被哪个对象调用，this就代表那个对象

- super

Super的用法和this很像，this代表本类对应的应用，super代表父类存储空间的标识（可以理解为父类引用）

- 区别

1.访问成员变量：this.成员变量 super.成员变量

2.访问构造方法：this()  super()

3.访问成员方法：this.成员方法(),super.成员方法

# 封装

- 概述

  是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

- 优点

  隐藏实现细节，提供公共的访问方式；提高了代码的复用性；提高安全性。

- 原则

  将不需要对外提供的内容都隐藏起来，把属性隐藏，提供公共方法对其访问。

# 继承

## 什么是继承

多个类中存在相同的属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那个类即可。通过extends关键字可以实现类与类的继承。

格式：Class 子类名  extends 父类名 {}

## 继承的优缺点

### 优点

提高了代码的复用性：多个类共同的成员可以放到一个类中。

提高了代码的维护性：如果功能代码需要修改，修改一处即可。

让类与类之间产生了关系，是多态的前提。

### 缺点

类的耦合性增强了，开发的原则，低耦合高内聚。

### 特点和注意事项

Java只支持单继承，不支持多继承。但是支持多层继承。

子类只能继承父类所有的非私有的成员方法和变量，子类不能继承父类的构造方法，但是可以通过super关键字去访问父类的构造方法。

## 继承中成员关系

### 成员变量

子类中的成员变量和父类中的成员变量不一致，在子类的局部范围找，然后在子类的成员范围找，在父类成员变量找。

### 成员方法

通过子类调用方法，先看子类有没有这个方法，如果没有就查找父类有没有这个方法。

### 构造方法

子类中所有的构造方法默认都会访问父类的空参数构造方法，及子类的每一个构造方法第一行都行都是super()，如果父类没有无参构造会报错。

## 重载和重写和覆盖

### 重写和覆盖

重写等于覆盖：如果子类中定义一个方法，其名称、返回值及参数签名正好与父类中某个方法的名称、返回类型及参数签名匹配，那么可以说子类的方法覆盖（重写）了父类的方法

> 1.子类的方法名称、参数签名（参数的类型，个数和顺序）和返回类型必须与父类的方法名称、参数签名和返回类型一致。
>
> 2.子类方法不能缩小父类方法的访问权限
>
> 3.子类方法不能抛出比父类方法更多的异常
>
> 4.方法覆盖（重写）值存在于子类和父类（包括直接和简介父类）之间
>
> 5.父类的静态方法不能被覆盖为非静态方法
>
> 6.子类可以定义和父类的静态方法同名的静态方法，以便在子类中隐藏父类的静态方法。
>
> 7.父类的非静态方法不能被子类覆盖为静态
>
> 8.父类的私有方法不能被子类覆盖

### 重载

对于类的方法（包括从父类中继承的方法），如果有两个方法的方法名相同，但参数不一致，那么可以说一个方法是另一个方法的重载方法

> 1.方法名相同
>
> 2.方法的参数类型，个数，顺序至少有一项不相同
>
> 3.方法的返回类型可以不相同
>
> 4.方法的修饰符可以不相同

## 子父类初始化顺序

1. 父类中静态成员变量和静态代码块

2. 子类中静态成员变量和静态代码块

3. 父类中普通成员变量和代码块，父类的构造函数

4. 子类中普通成员变量和代码块，子类的构造函数

# 多态

## 多态概念

同一事物，在不同时刻体现出来的不同状态。

## 多态前提

要有继承关系；要有方法重写；要有父类引用子类对象。

## 多态成员访问特点

- 成员变量

  编译看左边，运行看左边

- 成员方法

  编译看左边，运行看右边

- 静态方法

  编译看左边，运行看左边

# 语言修饰符

## 修饰符分类

1.权限修饰符：private、默认、protected、public

2.状态修饰符：static、final

3.抽象修饰符：abstract 

| 访问控制 | 访问控制修饰符 | 同类 | 同包 | 子类 | 不同的包 |
| -------- | -------------- | ---- | ---- | ---- | -------- |
| 公开     | public         | √    | √    | √    | √        |
| 受保护   | protected      | √    | √    | √    |          |
| 默认     | 没有           | √    | √    |      |          |
| 私有     | private        | √    |      |      |          |

## 修饰符使用场景

### 构造方法

权限修饰符：private ,默认的，protected，public

### 成员变量

权限修饰符：private ,默认的，protected，public

状态修饰符：static，final

### 成员方法

权限修饰符：private ,默认的，protected，public

状态修饰符：static，final

抽象修饰符：abstract

### 类

权限修饰符：默认修饰符，public

状态修饰符：final

抽象修饰符：abstract

## static

static是静态修饰符随着类的加载而加载，可以通过类名和对象调用。可以用来修饰成员方法和成员变量。静态方法只能访问静态变量和静态方法。

## final

### final概述

final及最终的意思可以用来修饰类，方法，变量。

### final的特点

- 修饰类：该类不能被继承
- 修饰方法：该方法不能被重写
- 修饰变量：该变量只能被赋值一次，不能被重新赋值，因为该变量就是常量。

## abstract

### abstract概述

在Java中一个没有方法体的方法应该定义为抽象方法，而类中如果没有抽象方法，该类必须定义为抽象类。

### abstract的特点

1.抽象方法和抽象类必须用abstract关键字修饰

2.抽象类中不一定有抽象方法，但是有抽象方法的类必须定义为抽象类

3.抽象类不能实例化，抽象类构造方法用于子类访问父类数据的初始化。

# 接口

## 接口概述

接口用关键字`interface`表示，类实现接口用`implements`,接口不能实例化，接口的子类可是抽象类或者具体类但是实现接口的所有方法。

## 成员特点

- 成员变量：只能是常量，并且是静态的，默认修饰符：`public static final `
- 构造方法：没有构造方法
- 成员方法：只能是抽象的，默认修饰符：`public abstract`

## 接口和类之间的关系

- 类与类：只能是单继承，但是可以多层继承
- 类与接口：可以说是单实现，也可以多实现
- 接口与接口：可以单继承，也可以多继承