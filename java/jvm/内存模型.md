# 计算机内存模型

## CPU缓存

计算机在执行程序的时候，每条指令都是在CPU中执行的，在CPU内部有一组CPU寄存器，寄存器是CPU直接访问和处理的数据，是一个临时放数据的空间。而执行的时候，CPU需要从主存(CPU内存)中存取数据到寄存器，然后执行。随着CPU技术的发展，CPU的执行速度越来越快，所以从内存中读取和写入数据的速度相比CPU的执行速度越来越慢，CPU每次操作内存都要耗费很多时间。

### CPU一级缓存

为了解决CPU执行速度和内存存取数据的速度差异过大，在CPU和内存之间增加高速缓存（速度快，内存小）。

现在程序运行过程：将运算需要的数据从主存复制一份到CPU高速缓存中，CPU计算时可以直接从它的高速缓存读取数据，当运算结束之后，先将数据刷新回CPU高速缓存中，然后再把数据刷新到主内存中。

![](../pic/L1_cache.png)

### CPU多级缓存

随着CPU能力的不断提升，一层缓存就已经无法满足要求了，就逐渐衍生出多级缓存，按照数据读取顺序和与CPU集合的紧密程度，CPU缓存可以分为一级缓存(L1)，二级缓存(L2)，高端的还有三级缓存(L3)，每一级缓存中所存储的全部数据都是下一级缓存的一部分。级别越小越接近Core速度越快，容量越小。

**现在程序的执行过程**：CPU读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还没有就从三级缓存中查找。

![](../pic/L1_L2_L3_cacahe.png)

### 多线程CPU

随着计算机能力不断提升，开始支持多线程。

- 单线程

CPU核心的缓存只被一个线程访问，缓存独占，不会出现访问冲突等问题。

- 单核CPU，多线程

进程中的多个线程会同时访问进程中的共享数据，CPU将某块内存加载到缓存后，不同线程在访问相同的物理地址的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。而且任何时候只能有一个线程在执行，因此不会出现缓存访问冲突。

- 多核CPU，多线程

每个核都至少有一个L1缓存。多个线程访问进程中的某个共享内存，且这个多线程分别在不同的核心上执行，则每个核心都会在各自的cache中保留一份共享内存的缓存，由于多核是可以并行的，可能会出现多个线程同时写各自的缓存的情况，而各自的缓存之间的数据就有可能不一样。

### CPU缓存一致性问题

在CPU和主存之间增加缓存，在多核多线程场景下就可能存在**缓存一致性**。在多处理器系统中，每个处理器都有自己的告诉缓存，而它们又共享同一主内存，当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自缓存数据不一致，为了解决一致性问题需要遵守一些协议：MSI、MESI、MOSI等。

![](../pic/multi_kernel_cpu_cache.png)

## 处理器优化

为了使处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入代码进行乱序执行处理，这就是**处理器优化**。

## 指令重排

Java虚拟机的及时编译器(JIT)也会对代码进行优化乱序处理，叫做**指令重排**。

# 并发编程

## 并发编程模型

并发编程模型是用于处理并发的通用手段，常见的并发编程模型有：基于线程与锁的内存共享模型，actor模型和csp模型。其中线程与锁的共享内存模型最为常见，Java内存模型也是基于此模型。

## 并发编程特性

并发编程为了保证数据的安全性，需要满足三个特性：原子性、可见性、有序性。这三个概念都是上层抽象的概念，实际上在底层对应的就是：缓存一致性、处理器优化、指令重排。

- **原子性**：原子性指的是一个操作是不可中断的，即使在多线程环境下，一个操作一旦开始就不会被其它线程影响。即不被中断操作，要不执行完成，要不就不执行。注：32位系统的long和double。原子性问题主要是处理器优化的结果。
- **可见性**：多个线程访问同一个变量时，一个线程修改了改变量的值，其他的线程要立刻可见。可见性主要解决办法是缓存一致性。
- **有序性**：有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的。但对于多线程环境，则可能出现乱序现象。造成程序有序性问题主要是指令重排。

# 内存模型

## 什么是内存模型

**为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。**通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

共享内存模型解决并发问题主要采用两种方式：**限制处理器优化**和**使用内存屏障**。

## 内存屏障

## 处理器优化

# Java内存模型 

## 什么是Java内存模型

Java内存模型是基于内存模型规范的，屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台都能达到一致的内存访问效果。主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存取出变量这样的底层细节。

此处的变量和Java的变量有所区别，它包括了：实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的。

> 为了获得较好的执行效能，Java内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。

## 主内存

主内存是公共区域，主要用于存储所有的变量。主内存勉强可以看做Java内存区域的堆，底层来说就是物理内存。

## 工作内存

工作内存是线程私有的，保存了线程使用了变量的主内存副本拷贝。线程对所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程之间变量值的传递均需要通过主内存来完成。工作内存勉强可以看做Java内存区域的栈，虚拟机会优先让工作内存存储于寄存器和高速缓存中。

![](../pic/main_work_memory_react.png)

## 内存交互操作

关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如果和工作内存同步回主内存之类的实现细节。Java内存模型定义了以下8种操作来完成，虚拟机实现时必须保证8种操作是原子的，不可再分的。(32位系统的long和double有例外)

- **lock-锁定：** 作用域主内存的变量，它把一个变量标识为一条线程独占的状态。
- **unlock-解锁：**作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
- **read-读取**：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
- **load-载入**：作用于工作内存的变量，它把read操作从主内存中的到的变量值放入工作内存的变量副本中。
- **use-使用**：作用于工作内存的变量，它把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
- **assign-赋值**：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
- **store-存储**：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
- **write-写入**：作用于主内存的变量，它把store操作从工作内存得到的变量的值放入主内存的变量中。

# Java内存模型的实现

​	在Java多线程中，可以直接使用`synchronized`等关键字来控制并发，我们不用关心底层的编译器优化、缓存一致性等问题。所以Java内存模型，除了定义一套规范，还提供了一些列原语，封装了底层实现。主要是解决原子性(处理器优化)、有序性(编译器重排)、可见性(缓存一致性)。

## 原子性

在Java中使用`synchronized`来保证方法和代码块内的操作是原子性的。

## 可见性

Java中的`volatile`关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用`volatile`来保证多线程操作时变量的可见性。

除了`volatile`，Java中的`synchronized`和`final`两个关键字也可以实现可见性。

## 有序性

在Java中，可以使用`synchronized`和`volatile`来保证多线程之间操作的有序性。实现方式有所区别：

`volatile`关键字会禁止指令重排。`synchronized`关键字保证同一时刻只允许一条线程操作。





